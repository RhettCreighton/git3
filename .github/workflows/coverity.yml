name: Coverity

# This GitHub workflow automates submitting builds to Coverity Scan. To enable it,
# set the repository variable `ENABLE_COVERITY_SCAN_FOR_BRANCHES` (for details, see
# https://docs.github.com/en/actions/learn-github-actions/variables) to a JSON
# string array containing the names of the branches for which the workflow should be
# run, e.g. `["main", "next"]`.
#
# In addition, two repository secrets must be set (for details how to add secrets, see
# https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions):
# `COVERITY_SCAN_EMAIL` and `COVERITY_SCAN_TOKEN`. The former specifies the
# email to which the Coverity reports should be sent and the latter can be
# obtained from the Project Settings tab of the Coverity project).
#
# By default, the builds are submitted to the Coverity project `git`. To override this,
# set the repository variable `COVERITY_PROJECT`.

on:
  push:

jobs:
  coverity:
    if: contains(fromJSON(vars.ENABLE_COVERITY_SCAN_FOR_BRANCHES || '[""]'), github.ref_name)
    runs-on: ubuntu-latest
    env:
      COVERITY_PROJECT: ${{ vars.COVERITY_PROJECT || 'git' }}
      COVERITY_LANGUAGE: cxx
      COVERITY_PLATFORM: linux64
    steps:
      - uses: actions/checkout@v3
      - run: ci/install-dependencies.sh
        env:
          runs_on_pool: ubuntu-latest

      # The Coverity site says the tool is usually updated twice yearly, so the
      # MD5 of download can be used to determine whether there's been an update.
      - name: get the Coverity Build Tool hash
        id: lookup
        run: |
          MD5=$(curl https://scan.coverity.com/download/$COVERITY_LANGUAGE/$COVERITY_PLATFORM \
                   --fail \
                   --form token='${{ secrets.COVERITY_SCAN_TOKEN }}' \
                   --form project="$COVERITY_PROJECT" \
                   --form md5=1) &&
          echo "hash=$MD5" >>$GITHUB_OUTPUT

      # Try to cache the tool to avoid downloading 1GB+ on every run.
      # A cache miss will add ~30s to create, but a cache hit will save minutes.
      - name: restore the Coverity Build Tool
        id: cache
        uses: actions/cache/restore@v3
        with:
          path: ${{ runner.temp }}/cov-analysis
          key: cov-build-${{ env.COVERITY_LANGUAGE }}-${{ env.COVERITY_PLATFORM }}-${{ steps.lookup.outputs.hash }}
      - name: download the Coverity Build Tool (${{ env.COVERITY_LANGUAGE }} / ${{ env.COVERITY_PLATFORM}})
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          curl https://scan.coverity.com/download/$COVERITY_LANGUAGE/$COVERITY_PLATFORM \
            --fail --no-progress-meter \
            --output $RUNNER_TEMP/cov-analysis.tgz \
            --form token='${{ secrets.COVERITY_SCAN_TOKEN }}' \
            --form project="$COVERITY_PROJECT"
      - name: extract the Coverity Build Tool
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          mkdir $RUNNER_TEMP/cov-analysis &&
          tar -xzf $RUNNER_TEMP/cov-analysis.tgz --strip 1 -C $RUNNER_TEMP/cov-analysis
      - name: cache the Coverity Build Tool
        if: steps.cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v3
        with:
          path: ${{ runner.temp }}/cov-analysis
          key: cov-build-${{ env.COVERITY_LANGUAGE }}-${{ env.COVERITY_PLATFORM }}-${{ steps.lookup.outputs.hash }}
      - name: build with cov-build
        run: |
          export PATH="$RUNNER_TEMP/cov-analysis/bin:$PATH" &&
          cov-configure --gcc &&
          cov-build --dir cov-int make -j$(nproc)
      - name: package the build
        run: tar -czvf cov-int.tgz cov-int
      - name: submit the build to Coverity Scan
        run: |
          curl \
            --fail \
            --form token='${{ secrets.COVERITY_SCAN_TOKEN }}' \
            --form email='${{ secrets.COVERITY_SCAN_EMAIL }}' \
            --form file=@cov-int.tgz \
            --form version='${{ github.sha }}' \
            "https://scan.coverity.com/builds?project=$COVERITY_PROJECT"
